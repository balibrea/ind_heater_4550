-- main_ind.jal
--
-- Copyright 2023 Yosel de Jes√∫s Balibrea Lastre <yosel.balibrea@gmail.com>
--
-- This program is free software; you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 2 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program; if not, write to the Free Software
-- Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
-- MA 02110-1301, USA.
--
--

--
;@jallib section chipdef
-- chip setup
include 18f4550

pragma target clock       20_000_000


-- fuses
pragma target PLLDIV        P5          -- divide by 5 - 20MHZ_INPUT
pragma target CPUDIV        P1          -- [primary oscillator src: /1][96 mhz pll src: /2]
pragma target USBDIV        P2          -- CLOCK_SRC_FROM_96MHZ_PLL_2
pragma target OSC           HS
pragma target FCMEN         DISABLED
pragma target IESO          DISABLED
pragma target PWRTE         DISABLED    -- power up timer
pragma target VREGEN        ENABLED     -- USB voltage regulator
pragma target VOLTAGE       MINIMUM     -- brown out voltage
pragma target BROWNOUT      DISABLED    -- no brownout detection
pragma target WDTPS         P32K        -- watch dog saler setting
pragma target WDT           CONTROL     -- watchdog software controlled
pragma target CCP2MUX       pin_C1      -- CCP2 on pin C1
pragma target PBADEN        DIGITAL     -- digital input port<0..4>
pragma target LPT1OSC       LOW_POWER   -- low power timer 1
pragma target MCLR          EXTERNAL    -- master reset on RE3
pragma target STVR          DISABLED    -- reset on stack over/under flow
pragma target LVP           DISABLED    -- no low-voltage programming
pragma target XINST         DISABLED     -- extended instruction set
pragma target DEBUG         DISABLED    -- background debugging
pragma target CP0           DISABLED    -- code block 0 not protected
pragma target CP1           DISABLED    -- code block 1 not protected
pragma target CP2           DISABLED    -- code block 2 not protected
pragma target CP3           DISABLED    -- code block 3 not protected
pragma target CPB           DISABLED    -- bootblock code not write protected
pragma target CPD           DISABLED    -- eeprom code not write protected
pragma target WRT0          DISABLED    -- table writeblock 0 not protected
pragma target WRT1          DISABLED    -- table write block 1 not protected
pragma target WRT2          DISABLED    -- table write block 2 not protected
pragma target WRT3          DISABLED    -- table write block 3 not protected
pragma target WRTB          DISABLED    -- bootblock not write protected
pragma target WRTD          DISABLED    -- eeprom not write protected
pragma target WRTC          DISABLED    -- config not write protected
pragma target EBTR0         DISABLED    -- table read block 0 not protected
pragma target EBTR1         DISABLED    -- table read block 1 not protected
pragma target EBTR2         DISABLED    -- table read block 2 not protected
pragma target EBTR3         DISABLED    -- table read block 3 not protected
pragma target EBTRB         DISABLED    -- boot block not protected

WDTCON_SWDTEN = OFF                     -- disable watchdog
;@jallib section ccp
-- no specific ccp settings, section required though to generate samples

enable_digital_io()                 -- make all pins digital I/O

include print
include delay
include debounce


-- IO Config -----------------------------------------------------
pin_P1A_direction = output
pin_P1B_direction = output
pin_P1A = off
pin_P1B = off

alias v_in is pin_B0
alias i_in is pin_B1

alias b_1 is pin_B2
alias b_2 is pin_B3
alias b_3 is pin_B4

pin_B0_direction = input
pin_B1_direction = input

pin_B4_direction = input
pin_B3_direction = input
pin_B2_direction = input

alias led is pin_B7
pin_B7_direction = output
------------------------------------------------------------------

-- Wait to power stabilice ---------------------------------------
delay_100ms(10)
------------------------------------------------------------------

-- Configure ADC ------------------------------------------------
-- We won't use any external VRef, so measures are done
-- according to PIC powering voltage
const byte ADC_NVREF = ADC_NO_EXT_VREF

--~ -- The maximum resistance while measuring ADC is... (unit: ohms)
--~ -- Being accurate helps speeding up ADC acquisition
--~ const word ADC_RSOURCE = 2_000
--~ -- In this example, we'll perform low resolution ADC: results are
--~ -- coded on 8bits

const bit ADC_HIGH_RESOLUTION = true
const byte ADC_NCHANNEL = 1
-- Now include the famous library
include adc

-- And initialize the whole with our parameters
adc_init()

-- Gloval variables ----------------------------------------------
var dword freq = 25_000
var dword debug_freq = 25_000
var word duty
var byte power = 2 -- 25% -> (4) 50% -> (2)
var byte phi = 0

var byte index = 0 -- Menu index
var bit power_on = off

var byte timer_s =0
var byte timer_m =10
var word timer_mm =0
var byte timer_h = 0

var byte timer_ss -- Set points
var byte timer_ms
var byte timer_hs

var bit update = true
var bit timer_en = false -- Enable/Disable count down

const byte THRESHOLD = 50

var word b1_st = debounce_init(THRESHOLD) -- Debounce
var word b2_st = debounce_init(THRESHOLD)
var word b3_st = debounce_init(THRESHOLD)

-- Debug vars
var byte debug_index = 0
var bit debug_flag = OFF

--------------------------------------------------------------------

-- PWM -----------------------------------------------------------
include pwm_hardware
pwm_max_resolution(1)

pwm_set_frequency(25000)
pwm1_set_dutycycle_percent(50)
pwm1_off()

-- Set output PWM stage configurations to work as
-- Half bridge output
procedure set_pwm_config() is
    pragma inline
    CCP1CON_CCP1M = 0xC
    CCP1CON_P1M = 2  -- Half bridge operation
    ECCP1DEL_PDC  = 15 -- Dead time
end procedure


-- Turn on PWM module
procedure turn_on() is
    if debug_flag then
        freq = debug_freq
    else
        duty = pwm_get_resolution()/power
    end if

    pwm_set_frequency(freq)
    pwm1_set_dutycycle_highres(duty)
    pwm1_on()

    set_pwm_config()
end procedure

------------------------------------------------------------------

-- Timer0 configuration ------------------------------------------
T0CON_T0CS = 0   -- internal clock
T0CON_PSA  = 0   -- assign prescaler to timer0
T0CON_T0PS = 2   -- prescaler 1:8
T0CON_T08BIT = 1 -- 8bit timer

INTCON_TMR0IF = off -- clear interupt flag
--~ INTCON_TMR0IE = on  -- Enable tmr0 interrupt
--~ INTCON_GIE  = on    -- Enable global interrupt
------------------------------------------------------------------

-- LCD Config ----------------------------------------------------
const byte LCD_ROWS    =  4           -- LCD with 2 lines
const byte LCD_CHARS   =  20          -- and 16 characters per line
--
alias     lcd_en       is pin_D7      -- data trigger
alias     lcd_rs       is pin_D6      -- command/data select.
pin_D6_direction       = output
pin_D7_direction       = output
--
alias     lcd_d4       is pin_D0
alias     lcd_d5       is pin_D1
alias     lcd_d6       is pin_D2
alias     lcd_d7       is pin_D3
--
pin_D0_direction       = output
pin_D1_direction       = output
pin_D2_direction       = output
pin_D3_direction       = output

include lcd_hd44780_4
include print
--
lcd_init()                            -- init the lcd controller

var byte line1[LCD_CHARS] = "Mi Cocina de Inducc "
var byte line2[LCD_CHARS]
var byte clock_line[LCD_CHARS] = " Tiempo: 00:00:00   "
var byte i, k
lcd_clear_screen()
print_string(lcd, line1)

delay_100ms(10)
lcd_clear_screen()

------------------------------------------------------------------

-- External Interrupts -------------------------------------------
INTCON2_INTEDG0 = 0 -- enable falling edge detection in INT0, INT1
INTCON2_INTEDG1 = 0

INTCON_INT0IF = 0 -- Clear interrupt flag
INTCON3_INT1IF = 0

INTCON_INT0IE = 1 -- Enable external interrupts INT0, INT1
INTCON3_INT1IE = 1

INTCON_GIE  = on    -- Enable global interrupt
------------------------------------------------------------------
procedure set_timer_on is

end procedure

procedure timer_off is

end procedure

procedure timer_count_down is
    if timer_en == true then
        if ((timer_h == timer_hs) & (timer_m == timer_ms) & (timer_s == timer_ss)) then
            power_on = false
        end if

        if timer_mm >= 1000 then
            timer_s = timer_s + BYTE(timer_mm/1000)
            timer_mm = timer_mm % 1000
        end if

        -- Set clock vars
        if timer_s > 59 then
            timer_s = 0
            timer_m = timer_m + 1

        elsif timer_m > 59 then
            timer_m = 0
            timer_h = timer_h + 1

        elsif timer_h > 2 then
            timer_h = 0
        end if

    end if
end procedure

procedure menu_home is
    if power_on == true then
        line1 = " APAGAR  TIMER  POT "
        line2 = clock_line
    else
        line1 = " ACTIVAR   POTENCIA "
        line2 = "       TIMER        "
    end if

    lcd_clear_screen()
    print_string(lcd, line1)

    lcd_cursor_position(1,0)
    print_string(lcd, line2)

end procedure

-- Debug Menu warning
procedure debug_msg is
    line1 = "Entrar en modo debug"
    line2 = "       SI      NO   "
    lcd_clear_screen()
    lcd_cursor_position(0,0)
    print_string(lcd, line1)
    lcd_cursor_position(1,0)
    print_string(lcd, line2)
end procedure

procedure menu_debug is

    const byte str0[] = "Freq: "
    const byte str1[] = "Phi: "
    const byte str2[] = "duty: "
    const byte str3[] = "Power status: "
    const byte str4[] = " Salir <-"

    lcd_clear_screen()
    lcd_cursor_position(0,0)

    if (debug_index < 4) then
        var byte n
        for 4 using n loop
            lcd_cursor_position(n,0)
            if (n == debug_index) then
                print_string(lcd, "->")
            else
                print_string(lcd, "  ")
            end if
        end loop

        lcd_cursor_position(0,2)
        print_string(lcd, str0)
        print_dword_dec(lcd, debug_freq)

        lcd_cursor_position(1,2)
        print_string(lcd, str1)
        --~ print_byte_dec(lcd, phi)
        print_byte_dec(lcd, debug_index)

        lcd_cursor_position(2,2)
        print_string(lcd, str2)
        print_dword_dec(lcd, duty)

        lcd_cursor_position(3,2)
        print_string(lcd, str3)
        print_byte_dec(lcd, power_on)
    else
        lcd_clear_screen()
        lcd_cursor_position(0,0)
        print_string(lcd, "->")
        print_string(lcd, str4)
    end if


end procedure

-- Set Time Menu
procedure menu_timer is
    line1 = " TIMER              "
    --~ line2 =

    lcd_clear_screen()
    lcd_cursor_position(0,0)
    print_string(lcd, line1)

    lcd_cursor_position(1,0)
    print_byte_dec(lcd, timer_hs)
    lcd = ":"
    print_byte_dec(lcd, timer_ms)
    lcd = ":"
    print_byte_dec(lcd, timer_ss)
    --~ print_string(lcd, line2)

end procedure

procedure menu_msg is
    line1 = "   Activar Timer?   "
    line2 = "       SI      NO   "

    lcd_clear_screen()
    lcd_cursor_position(0,0)
    print_string(lcd, line1)
    lcd_cursor_position(1,0)
    print_string(lcd, line2)

end procedure

-- Set Power Menu
procedure menu_power is
    const byte str[] = "Power: "
    lcd_clear_screen()
    lcd_cursor_position(0,0)
    print_string(lcd, str)
    if power == 2 then
        print_string(lcd, "50%")
    else
        print_string(lcd, "25%")
    end if

end procedure

-- Main Menu FSM
procedure menu_fsm is
    pragma inline

    -- Home Menu
    if index == 0 then
        if update == true then
            menu_home()
            update = off
        end if

        if (debounce(b_2, b2_st) == 2) then -- Switch to Timer Menu
            index = 1
            update = on
        end if

        if (debounce(b_3, b3_st) == 2) then -- Switch to Power Menu setting
            index = 2
            update = on
        end if

        if (debounce(b_1, b1_st) == 2) then -- Turn ON Power
            power_on = !power_on
            update = on
            if power_on == true then
                turn_on()
            else
                pwm1_off()
                pin_P1A = off -- Make sure all is off
                pin_P1B = off
            end if

        end if

    -- Timer Menu
    elsif index == 1 then
        if update == true then
            menu_timer()
            update = off
        end if

        if (debounce(b_1, b1_st) == 2) then -- ask to activate timer
            index = 3
            update = on

        elsif (debounce(b_2, b2_st) == 0) then
            timer_ss = timer_ss + 1
            if timer_ss >= 60 then
                timer_ss = 0
                timer_ms = timer_ms + 1
            elsif timer_ms >= 59 then
                timer_ms = 0
                timer_hs = timer_hs + 1
            elsif timer_hs > 1 then
                timer_hs = 0
            end if

        elsif (debounce(b_3, b3_st) == 0) then
            timer_ss = timer_ss - 1
            if timer_ss >= 60 then
                timer_ss = 0
                timer_ms = timer_ms - 1
            elsif timer_ms >= 59 then
                timer_ms = 0
                timer_hs = timer_hs - 1
            elsif timer_hs > 1 then
                timer_hs = 0
            end if
        end if

    -- Power Menu
    elsif index == 2 then
        if update == true then
            menu_power()
            update = off
        end if

        if (debounce(b_1, b1_st) == 2) then -- Go back home
            index = 0
            update = on
        elsif (debounce(b_2, b2_st) == 2) then
            power = 2
            if power_on == true then
                turn_on()
            end if
            update = on
        elsif (debounce(b_3, b3_st) == 2) then
            power = 4
            if power_on == true then
                turn_on()
            end if
            update = on
        end if

        if (debounce(b_1, b1_st) == 2 & debounce(b_2, b2_st) == 0) then -- Go Debug mode
           index = 4
           update = on
        end if


    -- Timer Msg Menu
    elsif index == 3 then -- Timer msg menu
        if update == true then
            menu_msg()
            update = off
        end if

        if (debounce(b_2, b2_st) == 2) then -- Turn on Timer
            timer_en = true
            index = 0
            update = true
            set_timer_on()
        end if

        if (debounce(b_3, b3_st) == 2) then -- Turn off Timer
            timer_en = false
            index = 0
            update = true
            timer_off()
        end if

    -- Debug Msg Menu
    elsif index == 4 then
        if update == true then
            debug_msg()
            update = off
        end if

        if (debounce(b_3, b3_st) == 2) then -- Go home
            index = 0
            update = true
        end if

        if (debounce(b_2, b2_st) == 2) then -- Go Debug
            index = 5
            update = true
        end if

    -- Debug Menu
    elsif index == 5 then
        if update == true then
            menu_debug()
            update = off
        end if

        debug_flag = ON -- Debug mode, some parameters changes!


        if (debug_index == 0) then
            -- Move freq up or down
            if (debounce(b_2, b2_st) == 2) then    -- UP
                update = on
                debug_freq = debug_freq + 100
                if (freq >= 50_000) then
                    freq = 50_000
                end if

                if (power_on) then
                    turn_on()
                end if
            end if

            if (debounce(b_3, b3_st) == 2) then   -- Down
                update = on
                debug_freq = debug_freq - 100
                if (freq <= 10_000) then
                    freq = 10_000
                end if

                if (power_on) then
                    turn_on()
                end if
            end if

        elsif (debug_index == 2) then
            -- Move duty up or down
            if (debounce(b_2, b2_st) == 2) then    -- UP
                update = on
                duty = duty + 1

                if (power_on) then
                    turn_on()
                end if
            end if

            if (debounce(b_3, b3_st) == 2) then   -- Down
                update = on
                duty = duty - 1

                if (power_on) then
                    turn_on()
                end if
            end if

        elsif (debug_index == 3) then
            -- Turn on or Off
            if (debounce(b_2, b2_st) == 2) then
                turn_on()
                power_on = on
                update = on
            end if

            if (debounce(b_3, b3_st) == 2) then
                power_on = off
                pwm1_off()
                pin_P1A = off -- Make sure all is off
                pin_P1B = off
                update = on
            end if

        end if

        -- Change arrow position to select parameters
        if (debounce(b_1, b1_st) == 2) then
            debug_index = debug_index + 1
            update = on
            if (debug_index > 4) then
                debug_index = 0
            end if
        end if

        if (debug_index == 4) then

            if (debounce(b_2, b2_st) == 2) then -- Go back home
                index = 0
                debug_index = 0
                debug_flag = OFF
                update = on
            end if

            if (debounce(b_3, b3_st) == 2) then -- Go back home
                index = 0
                debug_index = 0
                debug_flag = OFF
                update = on
            end if
        end if

    end if

end procedure

forever loop
    menu_fsm()

    timer_count_down()

    --~ delay_100ms(1)

end loop


procedure ISR is
    pragma interrupt

    if INTCON_TMR0IF == true then
        --~ INTCON_GIE  = off -- No more interrupts at this moment

        if timer_en == true then
            timer_mm = timer_mm + 819
        end if

        INTCON_TMR0IF = off   -- Clear interrupt flag
        --~ INTCON_GIE  = on      -- Enable Global interrupts
    end if

    if INTCON_INT0IF == true then
        INTCON_GIE  = off
        led = on
        INTCON_INT0IF = 0
        INTCON_GIE  = on
    end if

    if INTCON3_INT1IF == true then
        INTCON_GIE  = off
        led = off
        INTCON3_INT1IF = 0
        INTCON_GIE  = on
    end if

end procedure
